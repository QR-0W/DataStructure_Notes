# 数据结构

这是阅读王道、天勤等数据结构考研的复习笔记。

[TOC]



------



# 第一章 绪论

重点部分：

- 算法时间复杂度、空间复杂度的分析与计算

提示：

​	算法设计中通常会要求分析时间复杂度、空间复杂度，同时也会出现考察时间复杂度的选择题。



## 1.1 数据结构的基本概念

### 1.1.1 基本概念和术语

 1.  数据

     数据是信息的载体。

 2.  数据元素

     数据元素是数据的基本单位。

 3.  数据对象

     数据对象是具有相同性质的数据元素的集合，是数据的一个子集。

 4.  数据类型

     数据类型是一个值的集合和定义在此集合上的一组操作的总称。

 5.  数据结构

     数据结构包括：逻辑结构、存储结构和数据运算。

     

### 1.1.2 数据结构三要素

 1.  数据的逻辑结构

     逻辑结构与存储无关，是独立于计算机的。下面展示的是逻辑结构的分类：

     ![image-20230924152505191](./assets/image-20230924152505191.png)

 2.  数据的存储结构

     存储结构是指数据在计算机中的表示，也称为物理结构。

     1. 顺序存储
     2. 链式存储
     3. 索引存储
     4. 散列存储

     

 3.  数据的运算



## 1.2 算法和算法评价

### 1.2.1 算法的基本概念



### 1.2.2 算法效率的度量

 1.  时间复杂度

     时间复杂度的求解一般关注最坏情况下的时间复杂度。

     对于循环体，有：

     ​	时间复杂度取决于最大的那个循环最内层执行次数。

     对于递归，有：

     ​	先推导出类似$T(n)=aT(\frac{n}{b})+f(n)$形式的递推式（其中$f(n)$为一个确定的正函数）。

     ​	然后有
     $$
     T(n)=
     \left\{\begin{matrix} 
     	O(n^{log_{b}a}),\space \space O(n^{log_{b}a}) > O(f(n)) \\ 
     	O(f(n)log_{}n), \space \space O(n^{log_{b}a}) = O(f(n)) \\ 
     	O(f(n)),\space \space O(n^{log_{b}a}) < O(f(n)) 
     \end{matrix}\right.
     $$

 2.  空间复杂度

     空间复杂度有时也会关注平均/最好情况下的空间复杂度。





------



# 第二章 线性表

重点部分：

- 线性表的基本概念
- 线性表的实现：顺序存储、链式存储
- 线性表的应用

提示：线性表是算法题命题的重点，主要着重在性能优化（时间、空间复杂度）上。



## 2.1 线性表的定义和基本操作

### 2.1.1 线性表的定义

​	线性表是具有相同数据类型的 $n\ \ (n\ge0)$ 个元素的有限序列。



### 2.1.2 线性表的基本操作

​	线性表的主要操作如下：

```c++
InitList(&L)，初始化表。

Length(&L)，求表长，返回L的长度。

LocateElem(L, e)，按值查找，查找表中值为e的元素。

GetElem(L, i)，按位查找，获取第i个元素的值。

ListInsert(&L, i, e)，插入操作，在第i个位置上插入e。

ListDelete(&L, i, &e)，删除操作，删除第i个位置的元素，并用e返回删除元素的值。

PrintList(L)，输出L。

Empty(L)，判定L是否为空。

DestroyList(&L)，销毁线性表。
```



## 2.2 线性表的顺序表示

### 2.2.1 顺序表的定义

​	线性表的顺序存储称为<u>顺序表</u>，顺序表的特点是表中元素的逻辑顺序与物理顺序相同。

​	顺序表的存储类型可以描述为：

```C++
#define MaxSize 50
typedef struct{
    ElemType data[MaxSize];
    int length;
}SqList;	//静态分配
```

```C++
#define InitSize 100
typedef struct{
    ElemType *data;
    int MaxSize, length;
}SqList;	//动态分配

L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);	//For C
L.data = new ElemType[InitSize];						//For C++
```

​	假设线性表 $L$ 纯初的起始位置是 LOC(A)，sizeof(ElemType) 是每个数据元素所占用存储空间的大小，则L对应的顺序存储如图所示：

![image-20230924162218937](./assets/image-20230924162218937.png)

​	

### 2.2.2 顺序表上基本操作的实现



## 2.3 线性表的链式表示

### 2.3.1 单链表的定义



### 2.3.2 单链表上基本操作的实现



### 2.3.3 双链表



### 2.3.4 循环链表



### 2.3.5 静态链表



### 2.3.6 顺序表和链表的比较





------



# 第三章 栈、队列、数组



## 3.1 栈

### 3.1.1 栈的基本概念



### 3.1.2 栈的顺序存储结构



### 3.1.3 栈的链式存储结构



## 3.2 队列

### 3.2.1 队列的基本概念



### 3.2.2 队列的顺序存储结构



### 3.2.3 队列的链式存储结构



### 3.2.4 双端队列



## 3.3 栈和队列的应用

### 3.3.1 括号匹配



### 3.3.2 表达式求值



### 3.3.3 递归



### 3.3.4  层序遍历



### 3.3.5 计算机系统中的应用



## 3.4 数组和特殊矩阵

### 3.4.1 数组的定义



### 3.4.2 数组的存储结构



### 3.4.3 特殊矩阵的压缩存储



### 3.4.4 稀疏矩阵





------



# 第四章 串



## *4.1 串的定义和实现

### 4.1.1 串的定义



### 4.1.2 串的存储结构



### 4.1.3 串的基本操作



## 4.2 串的模式匹配

### 4.2.1 简单模式匹配算法



### 4.2.2 KMP算法



### 4.2.3 KMP算法的进一步优化





------



# 第五章 树



## 5.1 树的基本概念

### 5.1.1 树的定义



### 5.1.2 基本术语



### 5.1.3 树的性质



## 5.2 二叉树的概念

### 5.2.1 二叉树的定义及其主要特性



### 5.2.2 二叉树的存储结构



## 5.3 二叉树的遍历和线索二叉树

### 5.3.1 二叉树的遍历



### 5.3.2 线索二叉树



## 5.4 树、森林

### 5.4.1 树的存储结构



### 5.4.2 树、森林、二叉树的转换



### 5.4.3 树、森林的遍历



## 5.5 树与二叉树的应用

### 5.5.1 哈夫曼树、哈夫曼编码



### 5.5.2 并查集





------



# 第六章 图



## 6.1 图的基本概念

### 6.1.1 图的定义



## 6.2 图的存储以及基本操作

### 6.2.1 邻接矩阵法



### 6.2.2 邻接表法



### 6.2.3 十字链表法



### 6.2.4 邻接多重表



### 6.2.5 图的基本操作



## 6.3 图的遍历

### 6.3.1 广度优先搜索



### 6.3.2 深度优先搜索



### 6.3.3 图的遍历、图的连通性



## 6.4 图的应用

### 6.4.1 最小生成树



### 6.4.2 最短路径



### 6.4.3 有向无环图描述表达式



### 6.4.4 拓扑排序



### 6.4.5 关键路径



------



# 第七章 查找



## 7.1 查找的基本概念



## 7.2 顺序查找和折半查找

### 7.2.1 顺序查找



### 7.2.2 折半查找



### 7.2.3 分块查找



## 7.3 树形查找

### 7.3.1 二叉排序树



### 7.3.2 平衡二叉树



### 7.3.3 红黑树



## 7.4 B树、B+树

### 7.4.1 B树及其基本操作



### 7.4.2 B+树的基本概念



## 7.5 哈希（散列）表

### 7.5.1 散列表的基本概念



### 7.5.2 散列函数的构造方法



### 7.5.3 处理冲突的方法



### 7.5.4 散列查找及其性能分析





------



# 第八章 排序



## 8.1 排序的基本概念

### 8.1.1 排序的定义



## 8.2 插入排序

### 8.2.1 直接插入排序



### 8.2.2 折半插入排序



### 8.2.3 希尔排序



## 8.3 交换排序

### 8.3.1 冒泡排序



### 8.3.2 快速排序



## 8.4 选择排序

### 8.4.1 简单选择排序



### 8.4.2 堆排序



## 8.5 归并排序、基数排序

### 8.5.1 归并排序



### 8.5.2 基数排序



## 8.6 各种内部排序算法的比较和应用

### 8.6.1 内部排序算法比较



### 8.6.2 内部排序算法应用



## 8.7 外部排序

### 8.7.1 外部排序的基本概念



### 8.7.2 外部排序的方法



### 8.7.3 多路平衡归并与败者树



### 8.7.4 置换选择排序



### 8.7.5 最佳归并树









